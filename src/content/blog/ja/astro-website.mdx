---
title: Astro, Cloudflare Pages, Front Matter CMS で個人ブログを作った
description: Astro, Cloudflare Pages, Front Matter CMS の構成で個人ブログを開発・一般公開するまでの一連の流れを、重要なポイントを拾いつつ説明する
publishedAt: 2024-05-10T08:34:36.656Z
modifiedAt: 2024-05-10T08:34:39.640Z
tags:
  - JavaScript
  - TypeScript
  - Astro
category: Learning
draft: published
type: blog
---

## 概要

- Next.js から Astro に乗り換えて個人サイトを作った
- 全文検索機能(Pagefind)や多言語化対応などの機能が盛り込まれている
- Cloudflare はサイトのホスティングのみならず、独自ドメインの取得やそれに基づいたカスタムメールアドレスの取得まで幅広いサービスを提供している
- Front Matter CMS によってコードの修正、記事の執筆、サイトのデプロイがVS Code エディタ上に集約できる

## 導入

当ページで触れられていないトピックについては、他の有益な情報源をあたってみてください。

当サイトのソースコードに興味のある方は, [当サイトの Github レポジトリ](https://github.com)をご覧ください.

### 何について話さないか

- Astro のスターターテンプレートでプロジェクトを始める手順
- Git(Github)にプロジェクトを紐づける手順
- Cloudflare Pages にデプロイするまでの手順
- Cloudflare で独自ドメインを取得する方法
- Cloudflare Email Routing でカスタムメールアドレスを取得する方法
- Front Matter CMS を使い始めるまでの準備
- Astro (延いては、JS や TS) についての基本的な知識

### 何について話すか

- Astroで実装した特筆すべき機能について
- なぜホスティング先に Cloudflare Pages を選んだのか
- Front Matter CMS のカスタマイズについて

## 本題

### Astro

ReactなどのJSライブラリはなるべく使わず、素のJSだけで実装するようにしました。これを踏まえて、要不要はさておき、幾つかの機能をトッピングしています。

#### 全文検索

Rust製の静的検索ライブラリである[Pagefind](https://pagefind.app/)の力を借りることにしました。軽量、高速、そして非常に使いやすい！

`pagefind` と `@pagefind/default-ui` をプロジェクトに追加して, 次のような検索用コンポーネントを作りました。要点は、空の `div` タグに割り振られた`search` IDです。また、モーダルウィンドウは `hidden` クラスの有無に応じて表示が切り替わります。

```astro title="src/components/Search.astro"
---
import '@pagefind/default-ui/css/ui.css'
// ...
import Svg from '@/components/Svg/index.astro'
// ...
---
<div id="search-modal" class="hidden">
  <div id="search-wrapper">
    <div id="search"></div>
  </div>
</div>
<button
  type="button"
  id="search-icon-button"
  <!-- ... -->
>
  <Svg iconName="magnifier" width={32} height={32} />
</button>
<style>
  /* ... */
  #search-modal.hidden {
    display: none;
  }
  /* ... */
</style>
<!-- ... -->
```

次にJSの部分を見ていきましょう。`PagefindUI` インスタンスは `element` プロップを取り、これによって検索ウィンドウをどこに置くかを判断します。他にも、私の場合は検索結果に記事の画像を表示するかどうかや、記事の説明文の表示文字数のオプションも設定しました。詳しい情報は[Pagefind公式ドキュメント](https://pagefind.app/docs/ui/)をご覧ください。

`listenToModalEvents` の中身はイベント登録に関するコードです。PCユーザの為にショートカットキーや `escape` キーでモーダルの表示を切り替えられるようにしてあります。(PCからであれば `Ctrl + Shift + F` をお試しあれ！)

```astro title="src/components/Search.astro"
<!-- ... -->
<script>
  import { PagefindUI } from '@pagefind/default-ui'

  function initPagefind() {
    new PagefindUI({
      element: '#search',
      showImages: false,
      excerptLength: 20,
    })

    const listenToModalEvents = (
      modalButton: Element,
      modal: Element,
      input: HTMLInputElement
    ) => {
      modalButton.addEventListener('click', () => {
        modal.classList.toggle('hidden')
        input.focus()
      })

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.classList.toggle('hidden')
        }
      })

      window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          modal.classList.add('hidden')
        }
        if (e.code === 'KeyF' && e.ctrlKey && e.shiftKey) {
          e.preventDefault()
          modal.classList.toggle('hidden')
          input.focus()
        }
      })
    }

    const modalButton = document.querySelector('#search-icon-button')
    const modal = document.querySelector('#search-modal')
    const input = document.querySelector(
      '.pagefind-ui__search-input'
    ) as HTMLInputElement | null

    if (modalButton && modal && input) {
      listenToModalEvents(modalButton, modal, input)
    }
  }

  const eventsToBeAdded = [
    'DOMContentLoaded',
    'astro:after-swap',
    'visibilitychange',
  ] as const

  eventsToBeAdded.forEach((evName) => {
    document.addEventListener(evName, initPagefind)
  })
</script>
```

最後に、私の場合はこれをナビゲーション用コンポーネント内に追加しました。

```astro title="src/components/Navigation.astro" {4, 15}
---
// ...
import NavMenuContainer from '@/components/NavMenuContainer.astro'
import Search from '@/components/Search.astro'
// ...
---
<nav class="glassmorphism" data-pagefind-ignore="all">
  <!-- ... -->
  <NavMenuContainer>
    <div class="nav-links">
     <!-- ... -->
    </div>
    <div class="icon-links">
      <!-- ... -->
      <Search data-border-image-url="url(/border-image.gif)" />
    </div>
  </NavMenuContainer>
</nav>
<!-- ... -->
```

#### 多言語対応 (i18n)

[公式のドキュメント](https://docs.astro.build/ja/recipes/i18n/)に記載されている手順通りにロケール用のディレクトリを作成しました。(私の場合は `en` と `ja` です。一つのファイルに対して、言語の数と同じだけ同名のファイルを作成する必要があります)

Astro の Content Collections は Markdown/MDX ファイルフォーマットだけでなく、YAML や JSON形式にも対応しています。私は記事以外の翻訳文字列群の保存にYAML形式を選びました。非常に簡潔で好きです。

![content directory tree](../../../assets/images/content-dir.png)

Content Collectionsの詳しいカスタマイズについては、[公式ドキュメント](https://docs.astro.build/en/guides/content-collections/)をご覧あれ。

i18n対応についての重要なポイントは以下の通りです。`utils` ディレクトリ下に `i18n` ディレクトリがあり、次の2つのファイルが入っています。

```typescript title="src/utils/i18n/data.ts"
export const languages = {
  en: 'English',
  ja: '日本語',
}
export const langList = ['en', 'ja'] as const
export const defaultLang = 'en'
```

```typescript title="src/utils/i18n/getLocaleFromUrl.ts"
import { defaultLang, languages } from './data'

export const getLocaleFromUrl = (url: URL) => {
  const [, lang] = url.pathname.split('/')
  if (lang && lang in languages) return lang as keyof typeof languages

  return defaultLang
}
```

これらは次のようにして使います。言語選択コンポーネントを作成しました。

```astro title="src/components/LocalePicker.astro"
---
import { languages } from '@/utils/i18n/data'
import Svg from '@/components/Svg/index.astro'
import { getLocaleFromUrl } from '@/utils/i18n/getLocaleFromUrl'
// ...
const locale = getLocaleFromUrl(Astro.url)
const t = await getEntry('i18n', `${locale}/translation`)
const [_firstSlash, _prevLocale, ...rest] = Astro.url.pathname.split('/')
const slug = rest.join('/')
// ...
---

<div id="lang-modal" class="hidden">
  <div id="lang-wrapper">
    <ul class="lang-list">
      {
        Object.entries(languages).map(([lang, label]) => (
          <li>
            <a href={`/${lang}/${slug}`}>{label}</a>
          </li>
        ))
      }
    </ul>
  </div>
</div>
<button
  aria-label={t.data.locale_picker.button_label}
  type="button"
  id="lang-icon-button"
  title={t.data.locale_picker.button_label}
>
  <Svg iconName="language" width={32} height={32} />
</button>
<!-- ... -->
```

イベントの登録については、先ほど検索コンポーネントで紹介したのとほとんど同じです。飛ばして先へ進みましょう。

最後にナビゲーションコンポーネントに追加するところも同じです。

#### OG 画像 (Open Graph)

OG画像はAstroが提供する[APIエンドポイント機能](https://docs.astro.build/en/guides/endpoints/)で動的に生成します。より簡潔に実装したかったので、`astro-og-canvas` ライブラリの力を借りました。以下コードの流れは次の通りです。

1. OG画像を生成するコンテンツのデータを全取得する
2. データを加工して `OGImageRoute` が `pages` プロップとして受け取れるようにする
3. データを `OGImageRoute` に渡す

私の場合、ロケールディレクトリ導入の際にパスをいじっていた為、パスを少々加工しなければなりませんでした。

```typescript title="src/pages/og/[...slug].ts"
import { getCollection } from 'astro:content'
import { OGImageRoute } from 'astro-og-canvas'

const entries = await getCollection('blog')
const articles = Object.fromEntries(
  entries.map(({ slug, data, collection }) => {
    const locale = slug.slice(0, slug.indexOf('/'))
    const rawSlug = slug.slice(slug.indexOf('/') + 1)

    // e.g., "/en/blog/example1": { example1's data here }
    return [`${locale}/${collection}/${rawSlug}`, data]
  })
)

export const { getStaticPaths, GET } = OGImageRoute({
  param: 'slug', // this must be consistent with the dynamic path name
  pages: articles,
  getImageOptions: (_path, page: (typeof articles)[number]) => {
    return {
      title: page.title,
      description: page.description ?? '',
      bgGradient: [[26.99, 26.99, 30.99]],
      border: { color: [232, 232, 232], width: 5, side: 'block-end' },
      padding: 80,
      font: {
        title: {
          size: 64,
          lineHeight: 1.35,
          families: [
            'PixelMPlus10',
            'Arial',
            'Hiragino Kaku Gothic ProN',
            'Hiragino Sans',
          ],
          weight: 'Medium',
          color: [255, 255, 255],
        },
        description: {
          size: 36,
          lineHeight: 1.2,
          families: ['Arial', 'Hiragino Kaku Gothic ProN', 'Hiragino Sans'],
          weight: 'Normal',
          color: [255, 255, 255],
        },
      },
      logo: {
        path: './src/assets/images/logo.png',
        size: [80, 80],
      },
      fonts: ['./src/assets/fonts/PixelMplus10-Regular.woff2'],
    }
  },
})
```

その他のオプションについては、[astro-og-canvas 公式ドキュメント](https://github.com/delucis/astro-og-canvas/tree/latest/packages/astro-og-canvas)をご覧あれ。

これでOG画像用エンドポイントへアクセスできるようになりました。一つ例を見てみましょう。headの記述を切り出した `BaseHead` コンポーネントを作成し、こちらをベースレイアウトの中に設置しています。

```astro title="src/components/BaseHead.astro"
---
// ...
import type { Props as BaseLayoutProps } from '@/layouts/BaseLayout.astro'

type Props = BaseLayoutProps
// ...
const { title, description, og } = Astro.props
---
<!-- ... -->
<meta property="og:type" content="website" />
<meta property="og:url" content={Astro.url} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
{
  og.show && (
    <>
      <meta
        property="og:image"
        content={og.image ?? new URL('/blog-placeholder-1.jpg', Astro.url)}
      />
      <meta
        property="og:image:height"
        content={(og.height ?? 720).toString()}
      />
      <meta property="og:image:width" content={(og.width ?? 720).toString()} />
      <meta property="og:type" content={og.type ?? 'website'} />
    </>
  )
}
<meta property="twitter:url" content={Astro.url} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
{
  og.show && (
    <>
      <meta
        property="twitter:card"
        content={og.type === 'article' ? 'summary_large_image' : 'summary'}
      />
      <meta
        property="twitter:image"
        content={og.image ?? new URL('/blog-placeholder-1.jpg', Astro.url)}
      />
    </>
  )
}
<!-- ... -->
```

```astro title="src/layouts/BaseLayout.astro" {2, 24}
---
import BaseHead from '../components/BaseHead.astro'
// ...

// this is supposed to be imported from the BaseHead component
export type Props = {
  title: string
  description?: string
  og: {
    show: boolean
    image?: URL
    height?: number
    width?: number
    type?: 'article' | 'website'
  }
}

const { title, description, og } = Astro.props
---

<!doctype html>
<html lang={/* ... */}>
  <head>
    <BaseHead {title} description={description ?? ''} {og} />
  </head>
  <body data-pagefind-body>
    <!-- ... -->
  </body>
</html>
```

このページを含めて、当サイトの全てのブログ記事は次のレイアウトをテンプレートにしています。そしてそのブログレイアウトは、同様にベースレイアウトを踏襲しています。同時に、このマトリョシカのような構造の中で、`og` プロップがベースレイアウトへ、そしてheadコンポーネントへ、と渡されていきます。

```astro title="src/layouts/BlogLayout.astro" {24-33}
---
// ...
import type { MarkdownHeading } from 'astro'
import type { CollectionEntry } from 'astro:content'
// ...
import BaseLayout from '@/layouts/BaseLayout.astro'
// ...

type Props = {
  entry: CollectionEntry<'blog'>
  headings: MarkdownHeading[]
}

// ...
const { entry, headings } = Astro.props
const { data, collection, slug } = entry
const { title, description, category, tags, publishedAt, modifiedAt } = data
// ...
---

<BaseLayout
  title={title}
  description={description ?? ''}
  og={{
    show: true,
    height: 630,
    width: 1200,
    image: new URL(
      `/og/${locale}/${collection}/${slug.slice(slug.indexOf('/') + 1)}.png`,
      Astro.url
    ),
    type: 'article',
  }}
>
  <main>
    <!-- ... -->
  </main>
</BaseLayout>
<!-- ... -->
```

#### 記事内のCSSスタイリング

ブログ本文のCSSについて、全体の詳しい説明はさておき、ここでは幾つか例を挙げます。

##### KaTex

$\KaTeX$ はウェブページ上で数式などをきれいに表示してくれます。例えば、こちらの呪文が...

```Markdown
$$
x = {-b \pm \sqrt{b^2-4ac} \over 2a}
$$
$$
( \sum_{k=1}^{n} a_k b_k )^2 \leq ( \sum_{k=1}^{n} {a_k}^2 ) ( \sum_{k=1}^{n} {b_k}^2 )
$$
$$
\int_{0}^{1} f(x) \ dx
= \lim_{n \to \infty} \dfrac{1}{n} \sum_{k=0}^{n-1} f \left (\dfrac{k}{n} \right)
$$
```

こんな風に！とても読みやすくて感動します。

$$
x = {-b \pm \sqrt{b^2-4ac} \over 2a}
$$
$$
( \sum_{k=1}^{n} a_k b_k )^2 \leq ( \sum_{k=1}^{n} {a_k}^2 ) ( \sum_{k=1}^{n} {b_k}^2 )
$$
$$
\int_{0}^{1} f(x) \ dx
= \lim_{n \to \infty} \dfrac{1}{n} \sum_{k=0}^{n-1} f \left (\dfrac{k}{n} \right)
$$

$\KaTeX$ の利用に際して、`katex`、 `rehype-katex`、 `remark-math`、 `@types/katex` ライブラリを追加しました。そして次のようにコードを追加。

```typescript title="astro.config.ts" {2-3,10,14}
// ...
import remarkMath from 'remark-math'
import rehypeKatex from 'rehype-katex'
// ...
export default defineConfig({
  // ...
  markdown: {
    // ...
    remarkPlugins: [
      remarkMath,
      // ...
    ],
    rehypePlugins: [
      rehypeKatex,
      // ...
    ],
  },
})
```

私の場合、$\KaTeX$ のスタイルシートはブログレイアウトでのみ読み込ませています。他のページでは使う予定がないからです。

```astro title="src/layouts/BlogLayout.astro"
---
import 'katex/dist/katex.min.css'
// ...
---
<!-- ... -->
```

##### コードブロック

ここまでで、コードの説明に際してその都度コードブロックを使ってきましたが、シンタックスハイライトやコードの強調などのカスタマイズを裏で行っています。

`rehype-pretty-code`、`shiki` ライブラリを追加し、次の箇所を変更しました。Astroではデフォルトでシンタックスハイライト機能がついているので、カスタマイズする際には `syntaxHighlight` の項目を明示的に `false` にする必要があります。

\* `rehype-pretty-code` は内部で `shiki` を利用しているため、インストール必須です。

```typescript title="astro.config.ts" {2,7,11-20}
// ...
import rehypePrettyCode from 'rehype-pretty-code'
// ...
export default defineConfig({
  // ...
  markdown: {
    syntaxHighlight: false,
    // ...
    rehypePlugins: [
      // ...
      [
        rehypePrettyCode,
        {
          theme: {
            light: 'github-dark',
            dark: 'github-dark',
          },
          grid: false,
        },
      ],
      // ...
    ],
  },
})
```

次に、以下2つのコンポーネントを作成しました。このネスト構造 (と大半のCSS) については、[haxibami.net](https://www.haxibami.net/)のGithubレポジトリを参考にしました。

```astro title="src/components/elements/Figure.astro"
---
import AstroCode from './Code.astro'

export type Props = {
  'data-rehype-pretty-code-figure'?: ''
}

const props = Astro.props
const isCodeFigure = Object.hasOwn(props, 'data-rehype-pretty-code-figure')
---

{
  isCodeFigure ? (
    <AstroCode {...props}>
      <slot />
    </AstroCode>
  ) : (
    <figure {...props}>
      <slot />
    </figure>
  )
}
```

```astro title="src/components/elements/Code.astro"
---
const props = Astro.props
---

<figure {...props}>
  <slot />
</figure>
<style>
  figure {
    margin: 1.75rem 0 1.5rem 0;
    max-width: 86.5vw;
    position: relative;
    font-size: 0.85rem;
    & :global(pre) {
      border-radius: 0.25rem;
      overflow-x: auto;
    }
    & :global(code) {
      font-family: var(--code-font);
      counter-reset: line;
      display: grid;
      & :global([data-line]) {
        border-left: 4px solid transparent;
        padding: 0 0.55rem;
      }
      & :global([data-line]::before) {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        width: 1rem;
        margin-right: 1.05rem;
        text-align: right;
        color: var(--gray-light);
      }
      & :global([data-highlighted-line]) {
        border-left-color: var(--code-highlight-border);
        background-color: var(--code-highlight);
        :global(span) {
          background-color: unset;
        }
      }
      & :global([data-highlighted-chars]) {
        background-color: var(--gray-light);
        padding: 0.25rem;
        border-radius: 0.25rem;
        & :global(span) {
          background-color: unset;
        }
      }
    }
    & :global([data-rehype-pretty-code-title]) {
      font-family: var(--code-font);
      & + :global(pre) {
        padding: 2.85rem 0 0.75rem 0;
      }
    }
    & :global(pre:not([data-rehype-pretty-code-title] + pre)) {
      padding: 0.75rem 0;
    }
    & :global([data-rehype-pretty-code-title]) {
      max-width: 70vw;
      position: absolute;
      top: 0;
      left: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      padding: 0.25rem 0.75rem;
      color: var(--gray-dark);
      background: var(--gray);
      border-radius: 0.15rem 0.15rem 0.15rem 0;
    }
  }
  @media (min-width: 1024px) {
    figure {
      max-width: 59.5vw;
    }
  }
  :global(pre[data-theme*=' ']),
  :global(pre[data-theme*=' '] span) {
    color: var(--shiki-light);
    background: var(--shiki-light-bg);
  }
</style>
```

##### アンカーリンク付き見出し

この記事も含め、全てのブログ記事内の見出しにはアンカーリンクが付いています。このおかげで、目次が見出しを検知して、私たちをそれぞれの場所へ案内してくれます。

`rehype-autolink-headings`、`rehype-slug`、`hastscript` ライブラリを追加して、次の箇所を変更します。

\* `rehype-slug` は `id` 属性を見出しに追加し、`hastscript` は構文が変化する際に抽象構文木(AST, Abstract Syntax Trees)を操作できます

```typescript title="astro.config.ts" {2-4,10-22}
// ...
import { h } from 'hastscript'
import rehypeSlug from 'rehype-slug'
import rehypeAutolinkHeadings from 'rehype-autolink-headings'
// ...
export default defineConfig({
  // ...
  markdown: {
    // ...
    rehypePlugins: [
      // ...
      rehypeSlug,
      [
        rehypeAutolinkHeadings,
        {
          behavior: 'prepend',
          content: h(
            'span.heading-anchor-icon',
            {
              title: 'Anchor link',
            },
            ['#']
          ),
        },
      ],
      // ...
    ],
  },
})
```

それから、すべてのコンテンツ用レイアウトでアンカーリンクのCSSを追記しました。以下はブログレイアウトの例です。

```astro title="src/components/BlogLayout.astro" {19-32}
---
// ...
---

<BaseLayout
  <!-- ... -->
>
  <main>
    <article>
      <!-- ... -->
    </article>
  </main>
</BaseLayout>
<style>
  article {
    /* ... */
    .prose {
      /* ... */
      & :global(a):has(.heading-anchor-icon) {
        text-decoration: none;
        font-family: var(--base-font);
        & :global(span.heading-anchor-icon) {
          color: var(--fg);
          margin-right: 0.5rem;
        }
        &:hover {
          text-decoration: underline;
          text-underline-offset: 4px;
          text-decoration-color: var(--fg);
        }
        /* ... */
      }
    }
  }
</style>
```

### Front Matter CMS

フレームワーク選定の他には、CMS(Content Management System)選定もかなりの時間を要します。私は [Front Matter CMS](https://frontmatter.codes/) に惹かれました。理由は次の通りです。

- ローカルで記事の執筆や保存ができる
- マークダウン/MDX形式

It's unlike other headless CMS in that it's a VS Code extension and works in local, in your code editor! This centralizes all the editing work: code tweaks, blog writing, and deployment. I believe it'd especially be a huge advantage to developers.

When it comes to the setup, consult [the Front Matter official doc](https://frontmatter.codes/docs/getting-started). During the procedure, it automatically detects Astro's content folder and creates content types in the `frontmatter.json` accordingly.

#### Front Matter CMS のカスタマイズ

In the `frontmatter.json`, there are two notable points here:

- `frontMatter.content.publicFolder`: it refers to the public folder by default. I wanted to use [the asset directory](https://docs.astro.build/ja/guides/images/) Astro offers for image optimization, so changed it to `src/assets/images/`
- `frontMatter.content.i18n`: Front Matter CMS also covers an i18n feature. With this setting, it can spot the association between locales and directories

```json title="frontmatter.json"
{
  "$schema": "https://frontmatter.codes/frontmatter.schema.json",
  "frontMatter.framework.id": "astro",
  "frontMatter.preview.host": "http://localhost:4321",
  "frontMatter.content.publicFolder": "./src/assets/images/",
  "frontMatter.content.pageFolders": [
    {
      "title": "blog",
      "path": "[[workspace]]/src/content/blog",
      "contentTypes": [
        "blog"
      ],
      "defaultLocale": "en"
    },
    // ...
  ],
  "frontMatter.content.i18n": [
    {
      "title": "English",
      "locale": "en",
      "path": "en"
    },
    {
      "title": "Japanese",
      "locale": "ja",
      "path": "ja"
    }
  ],
  "frontMatter.content.draftField": {
    "name": "draft",
    "type": "choice",
    "choices": [
      "draft",
      "in progress",
      "published"
    ]
  },
  "frontMatter.taxonomy.seoTitleLength": 72,
  "frontMatter.taxonomy.contentTypes": [
    {
      "name": "blog",
      "pageBundle": false,
      "previewPath": "'blog'",
      "filePrefix": null,
      "clearEmpty": true,
      "fileType": "mdx",
      "fields": [
        {
          "title": "Title",
          "name": "title",
          "type": "string",
          "single": true,
          "required": true
        },
        {
          "title": "Description",
          "name": "description",
          "type": "string"
        },
        {
          "title": "Category",
          "name": "category",
          "type": "categories",
          "required": true,
          "taxonomyLimit": 1,
          "singleValueAsString": true
        },
        {
          "title": "Tags",
          "name": "tags",
          "type": "tags"
        },
        {
          "title": "Draft status",
          "name": "draft",
          "type": "draft",
          "required": true,
          "default": "draft"
        },
        {
          "title": "Published At",
          "name": "publishedAt",
          "type": "datetime",
          "default": "{{now}}",
          "isPublishDate": true
        },
        {
          "title": "Modified At",
          "name": "modifiedAt",
          "type": "datetime",
          "isModifiedDate": true
        },
        {
          "title": "type",
          "name": "type",
          "type": "string"
        },
        {
          "title": "draft",
          "name": "draft",
          "type": "draft"
        }
      ]
    },
    // ...
  ],
  // ...
}
```

My dashboard looks like this. It's fully comparable to other CMS, isn't it?

![ My Front Matter CMS dashboard ](../../../assets/images/front-matter-cms-dashboard.png)

![ My Front Matter CMS editing mode ](../../../assets/images/front-matter-cms-editing.png)

### Cloudflare Pages

When I was into Next.js, my go-to hosting service was Vercel, but it felt like I needed to revisit it along with the transition to Astro. I came to a conclusion: [Cloudflare Pages](https://developers.cloudflare.com/pages/).

#### どうして Cloudflare?

I decided to use Cloudflare Pages to host my website for the following reasons:

- The generous free plan
  - The unlimited maximum bandwidth per month is awesome (As of May 9, 2024)
- Lightning fast deployment
- Custom email addresses for your domain available
- Own domains available (paid)

I suppose the free plan suffices for a small project like my website. That's the most appealing factor to me.

## 後記

I spent a tremendous amount of time reading articles about how to create my personal website, watching a bunch of tutorials for various JS frameworks on YouTube, and actually getting to work on it. As a novice, it felt as if I were stargazing when I was looking for a constellation of frameworks.

Among them, I bumped into outstanding and brilliant one above all: Next.js, a framework for React. Since then, I started creating my personal website, simultaneously learning it. After 8 months or so, I successfully built a decent Next.js website.

However, long story short, we broke up finally. How come? It's fascinating in providing a full range of features, handling the backend stuff on behalf of me, and so on, but therein lies the rub; as it upgrades and becomes equipped with a lot more features, it seems to be deviating from the JS standard. Plus, I've found it hard to catch up with those continuously upcoming features. (I barely stuck at it until the App Router...)

In the end, I encountered with Astro, a framework for JS frameworks, if you like. What I love most about it is its flexibility; it keeps its functionality to a bare minimum and leaves enough room for your customization. In my case, I avoid using such JS frameworks as React where possible and stick to using vanilla JS(TypeScript).
