---
import { getEntry } from 'astro:content'
import { getLocaleFromUrl } from '@/utils/i18n/getLocaleFromUrl'
import { useTranslatedPath } from '@/utils/i18n/useTranslatedPath'
import { FORM_TEXTAREA_ROWS, FORM_TEXTAREA_MINLENGTH } from '@/consts'

const locale = getLocaleFromUrl(Astro.url)
const translatePath = useTranslatedPath(locale)
const t = await getEntry('i18n', `${locale}/translation`)
---

<form
  id="contact-form"
  action={translatePath('/api/form')}
  method="post"
  novalidate
>
  <label for="name">{t.data.contact.name.label}</label>
  <div class="pokemon-border">
    <input type="text" id="name" name="name" autocomplete="off" required />
  </div>
  <div id="name-required" class="error hidden">
    {t.data.contact.name.required}
  </div>
  <label for="email">{t.data.contact.email.label}</label>
  <div class="pokemon-border">
    <input type="email" id="email" name="email" required />
  </div>
  <div id="email-required" class="error hidden">
    {t.data.contact.email.required}
  </div>
  <div id="email-invalid" class="error hidden">
    {t.data.contact.email.invalid}
  </div>
  <label for="message">{t.data.contact.message.label}</label>
  <div class="pokemon-border">
    <textarea
      id="message"
      name="message"
      rows={FORM_TEXTAREA_ROWS}
      minlength={FORM_TEXTAREA_MINLENGTH}
      autocomplete="off"
      required></textarea>
  </div>
  <div id="message-required" class="error hidden">
    {t.data.contact.message.required}
  </div>
  <div id="message-minlength" class="error hidden">
    {t.data.contact.message.minlength}
  </div>
  <section class="checkbox-area">
    <input type="checkbox" id="confirmCheck" name="confirmCheck" required />
    <label for="confirmCheck">{t.data.contact.confirmation.label}</label>
  </section>
  <div id="confirmCheck-required" class="error hidden">
    {t.data.contact.confirmation.required}
  </div>
  <div
    class="cf-turnstile"
    data-sitekey={import.meta.env.TURNSTILE_SITE_KEY}
    data-language={locale}
  >
  </div>
  <button class="pokemon-border" type="submit"
    >{t.data.contact.sendLabel}</button
  >
</form>
<style>
  form {
    display: flex;
    flex-direction: column;
    gap: 0.875rem;
    label {
      user-select: none;
    }
    div {
      display: flex;
      flex-direction: column;
      input[type='text'],
      input[type='email'],
      textarea {
        padding: 0.5rem;
        background-color: var(--bg);
        outline: none;
      }
    }
    .checkbox-area {
      margin-top: 1.5rem;
      input[type='checkbox'] {
        align-self: flex-start;
      }
    }
    .cf-turnstile {
      margin: 0 auto;
    }
    button {
      font-weight: 600;
      margin-top: 1.25rem;
      padding: 0.25rem 1.85rem;
      align-self: center;
    }
    .error {
      color: var(--callout-failure-fg);
      background-color: var(--callout-failure-bg);
      padding: 0.5rem;
      border-radius: 0.25rem;
      &.hidden {
        display: none;
      }
    }
  }
</style>
<script>
  import { createSignal, onMount } from 'solid-js'

  onMount(() => {
    const script = document.createElement('script')
    script.src = 'https://challenges.cloudflare.com/turnstile/v0/api.js'
    script.async = true
    script.defer = true
    document.body.appendChild(script)
  })

  function init() {
    const formElement = document.getElementById(
      'contact-form'
    ) as HTMLFormElement

    // let isValid = true
    const [isValid, setIsValid] = createSignal(true)

    const inputElements = document.querySelectorAll<
      HTMLInputElement | HTMLTextAreaElement
    >("input:not([type='hidden']), textarea")

    inputElements.forEach((elem) => {
      if (
        elem.tagName === 'INPUT' &&
        elem.getAttribute('type') === 'checkbox'
      ) {
        elem.addEventListener('change', () => {
          validate(elem)
        })
      } else {
        elem.addEventListener('blur', () => {
          validate(elem)
        })
      }
    })

    formElement.addEventListener('submit', async (event) => {
      event.preventDefault()

      for (const elem of inputElements.values()) {
        validate(elem)
      }

      if (isValid()) {
        const formData = new FormData(formElement)
        const response = await fetch(formElement.action, {
          method: 'POST',
          body: formData,
        })

        if (response.ok && response.redirected) {
          window.location.replace(response.url)
        } else {
          formElement.reset()
          alert('Error submitting form. Please try again.')
        }
      }
    })

    const validate = (elem: HTMLInputElement | HTMLTextAreaElement) => {
      const elemName = elem.getAttribute('name')!
      const validityState = elem.validity
      const requiredError = document.getElementById(
        elemName + '-required'
      ) as HTMLDivElement

      switch (elemName) {
        case 'name':
          if (validityState.valueMissing) {
            requiredError.classList.remove('hidden')
            // isValid = false
            setIsValid(false)
          } else {
            requiredError.classList.add('hidden')
          }
          break
        case 'email':
          const invalidError = document.getElementById(
            elemName + '-invalid'
          ) as HTMLDivElement
          if (validityState.valueMissing) {
            requiredError.classList.remove('hidden')
            invalidError.classList.add('hidden')
            // isValid = false
            setIsValid(false)
          } else if (validityState.typeMismatch) {
            requiredError.classList.add('hidden')
            invalidError.classList.remove('hidden')
            // isValid = false
            setIsValid(false)
          } else {
            requiredError.classList.add('hidden')
            invalidError.classList.add('hidden')
          }
          break
        case 'message':
          const minlengthError = document.getElementById(
            elemName + '-minlength'
          ) as HTMLDivElement
          if (validityState.valueMissing) {
            requiredError.classList.remove('hidden')
            minlengthError.classList.add('hidden')
            // isValid = false
            setIsValid(false)
          } else if (validityState.tooShort) {
            requiredError.classList.add('hidden')
            minlengthError.classList.remove('hidden')
            // isValid = false
            setIsValid(false)
          } else {
            requiredError.classList.add('hidden')
            minlengthError.classList.add('hidden')
          }
          break
        case 'confirmCheck':
          if (validityState.valueMissing) {
            requiredError.classList.remove('hidden')
            // isValid = false
            setIsValid(false)
          } else {
            requiredError.classList.add('hidden')
          }
          break
      }
    }
  }

  const eventsToBeAdded = ['DOMContentLoaded', 'pageshow'] as const

  eventsToBeAdded.forEach((evName) => {
    document.addEventListener(evName, init)
  })
</script>
