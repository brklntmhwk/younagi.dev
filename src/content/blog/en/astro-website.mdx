---
title: Build a personal blog with Astro, Cloudflare Pages, and Front Matter CMS
description: I describe some noteworthy features developed with Astro, Cloudflare Pages, and FrontMatter CMS.
publishedAt: 2024-05-07T09:13:00.135Z
modifiedAt: 2024-02-26T05:20:13.043Z
tags:
  - Astro
  - TypeScript
  - JavaScript
category: Learning
draft: published
type: blog
---

## TL:DR

- I created my website switching over from Next.js to Astro
- My Astro website is equipped with some features like dark/light mode toggle, full-text search(Pagefind), internationalization(i18n) and more
- Cloudflare offers a wide range of support for, from hosting your website and getting your own domain, to creating your custom email address for it.
- Front Matter CMS enables you to write an article, tweak code, build and deploy your website in your VS Code editor

## Intro

As to the topics not covered here, consult other helpful info sources.

If you're interested in the code behind my website, see [my Github repo](https://github.com).

### What is not covered

- Launching your project with the Astro starter template
- Connecting it to Git(Github)
- Deploying it on Cloudflare Pages
- Getting an own domain on Cloudflare
- Creating a custom email address using Cloudflare Email Routing
- Preparation for using Front Matter CMS
- Basic knowledge about Astro (by extension, JS and TS)

### What is covered

- Some noteworthy features developed with Astro
- Why I chose Cloudflare Pages for deployment
- Customization of Front Matter CMS

## Main

### Astro

I avoid using other JS frameworks like React inside Astro and stick to vanilla JS as much as possible. With that in mind, I topped some features, whether necessary or not, on my website.

#### Dark/light mode switch

I was able to develop it thanks to [the official tutorial page](https://docs.astro.build/ja/tutorial/6-islands/2/). (some parts have been modified though)

The points here are the `id` attribute of the `button` element and the `display` styles alternately applied to the `sun` and `moon` classes, both of which will later be used in the JS part.

```astro title="ThemeToggle.astro"
---
// ...
import Svg from '@/components/Svg/index.astro'
// ...
---

<button
  id="theme-toggle-button"
  type="button"
  <!-- ... -->
>
  <Svg class="sun" iconName="sun" width={32} height={32} />
  <Svg class="moon" iconName="moon" width={32} height={32} />
</button>
<style>
  /* ... */
  .sun {
    display: inline-block;
  }
  .moon {
    display: none;
  }
  :global(.dark) .sun {
    display: none;
  }
  :global(.dark) .moon {
    display: inline-block;
  }
</style>
<!-- ... -->
```

Simply put, it's supposed to:

- check the user's system preference and set the theme accordingly
  - every time it changes, the theme does so too accordingly
- toggle the theme when clicked or tapped

Once the `init` function is triggered, the local storage key `theme` is created and the current theme value (`"dark"` or `"light"`) is stored in it. At the same time, the `dark` class is applied to or removed from the html tag to make things coherent.

```astro title="ThemeToggle.astro"
<!-- ... -->
<script>
  type themeType = 'dark' | 'light' | null

  function init() {
    const element = document.documentElement
    const isDarkPreferred = window.matchMedia(
      '(prefers-color-scheme: dark)'
    ).matches
    const preferredTheme = isDarkPreferred ? 'dark' : 'light'
    const theme = ((): themeType => {
      if (
        typeof localStorage !== 'undefined' &&
        localStorage.getItem('theme')
      ) {
        return localStorage.getItem('theme') as themeType
      } else {
        return preferredTheme
      }
    })()

    switch (theme) {
      case 'light':
        element.classList.remove('dark')
        break
      case 'dark':
        element.classList.add('dark')
        break
      default:
        isDarkPreferred
          ? element.classList.add('dark')
          : element.classList.remove('dark')
        break
    }

    window.localStorage.setItem('theme', theme || preferredTheme)

    const handleToggleClick = () => {
      element.classList.toggle('dark')

      const isDark = element.classList.contains('dark')
      localStorage.setItem('theme', isDark ? 'dark' : 'light')
    }

    const handleMediaQuery = (e: MediaQueryListEvent | MediaQueryList) => {
      if (e.matches) {
        element.classList.add('dark')
        localStorage.setItem('theme', 'dark')
      } else {
        element.classList.remove('dark')
        localStorage.setItem('theme', 'light')
      }
    }

    const themeButton = document.getElementById('theme-toggle-button')
    if (themeButton) themeButton.addEventListener('click', handleToggleClick)
    window
      .matchMedia('(prefers-color-scheme: dark)')
      .addEventListener('change', handleMediaQuery)
  }

  const eventsToBeAdded = ['DOMContentLoaded', 'astro:after-swap'] as const

  eventsToBeAdded.forEach((evName) => {
    document.addEventListener(evName, init)
  })
</script>
```

Finally, don't forget to add CSS variables (I'd say they are more of constants though) for both light and dark modes, and import it from and place it to where it's supposed to be. In my case, it should be in the navigation.

```css title="global.css"
:root {
  --fg: hsla(248.57, 11.48%, 11.96%, 1);
  --bg: hsla(0, 0%, 96.7%, 1);
  /* ... */
}
:root.dark {
  --fg: hsla(0, 0%, 96.7%, 1);
  --bg: hsla(248.57, 11.48%, 11.96%, 1);
  /* ... */
}
```

```astro title="Navigation.astro" {4, 15}
---
// ...
import NavMenuContainer from '@/components/NavMenuContainer.astro'
import ThemeToggle from '@/components/ThemeToggle.astro'
// ...
---
<nav class="glassmorphism" data-pagefind-ignore="all">
  <!-- ... -->
  <NavMenuContainer>
    <div class="nav-links">
     <!-- ... -->
    </div>
    <div class="icon-links">
      <!-- ... -->
      <ThemeToggle />
    </div>
  </NavMenuContainer>
</nav>
<!-- ... -->
```

#### Full text search

I decided to use [Pagefind](https://pagefind.app/), a Rust based static search library. It's lightweight, lightning fast, and easy to use!

After adding the `pagefind` and `@pagefind/default-ui` library to my project, I created the search component like this. The point is the `search` id given to an empty `div` tag. Plus, the modal window toggles in response to the presence of the `hidden` class.

```astro title="Search.astro"
---
import '@pagefind/default-ui/css/ui.css'
// ...
import Svg from '@/components/Svg/index.astro'
// ...
---
<div id="search-modal" class="hidden">
  <div id="search-wrapper">
    <div id="search"></div>
  </div>
</div>
<button
  type="button"
  id="search-icon-button"
  <!-- ... -->
>
  <Svg iconName="magnifier" width={32} height={32} />
</button>
<style>
  /* ... */
  #search-modal.hidden {
    display: none;
  }
  /* ... */
</style>
<!-- ... -->
```

Now, let's move on to the JS part. the `PagefindUI` instance takes the `element` prop that spots where to put the search window. Other than that, I specified the image option and excerpt length as you can see. For more info about the props, consult [the official doc](https://pagefind.app/docs/ui/).

Inside the `listenToModalEvents` is event registration code. For PC users, I added a shortcut key for searching and enabled the escape key to toggle it. (Hit `Ctrl + Shift + F` if you're on PC right now!)

```astro title="Search.astro"
<!-- ... -->
<script>
  import { PagefindUI } from '@pagefind/default-ui'

  function initPagefind() {
    new PagefindUI({
      element: '#search',
      showImages: false,
      excerptLength: 20,
    })

    const listenToModalEvents = (
      modalButton: Element,
      modal: Element,
      input: HTMLInputElement
    ) => {
      modalButton.addEventListener('click', () => {
        modal.classList.toggle('hidden')
        input.focus()
      })

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.classList.toggle('hidden')
        }
      })

      window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          modal.classList.add('hidden')
        }
        if (e.code === 'KeyF' && e.ctrlKey && e.shiftKey) {
          e.preventDefault()
          modal.classList.toggle('hidden')
          input.focus()
        }
      })
    }

    const modalButton = document.querySelector('#search-icon-button')
    const modal = document.querySelector('#search-modal')
    const input = document.querySelector(
      '.pagefind-ui__search-input'
    ) as HTMLInputElement | null

    if (modalButton && modal && input) {
      listenToModalEvents(modalButton, modal, input)
    }
  }

  const eventsToBeAdded = [
    'DOMContentLoaded',
    'astro:after-swap',
    'visibilitychange',
  ] as const

  eventsToBeAdded.forEach((evName) => {
    document.addEventListener(evName, initPagefind)
  })
</script>
```

Finally, I added it to the navigation as I did for the theme switch component.

#### Internationalization (i18n)

I was able to develop it thanks to [the official doc](https://docs.astro.build/ja/recipes/i18n/). First, I followed the steps and created locale directories (`en` and `ja`, in my case. You've got to make as many files as the number of languages for the same content.

Astro doesn't offer only Markdown/MDX file format, but also those of YAML and JSON. I chose YAML for storing translation strings because of its brevity.

![content directory tree](../../../assets/images/content-dir.png)

When it comes to the configuration, consult [the official doc for Content Collections](https://docs.astro.build/en/guides/content-collections/).

Here are some important parts about i18n settings. Under the `utils` directory is that of `i18n`, which contains two files.

```typescript title="data.ts"
export const languages = {
  en: 'English',
  ja: '日本語',
}
export const langList = ['en', 'ja'] as const
export const defaultLang = 'en'
```

```typescript title="getLocaleFromUrl.ts"
import { defaultLang, languages } from './data'

export const getLocaleFromUrl = (url: URL) => {
  const [, lang] = url.pathname.split('/')
  if (lang && lang in languages) return lang as keyof typeof languages

  return defaultLang
}
```

These are used like below. I created the locale picker component leveraging them.

```astro title="LocalePicker.astro"
---
import { languages } from '@/utils/i18n/data'
import Svg from '@/components/Svg/index.astro'
import { getLocaleFromUrl } from '@/utils/i18n/getLocaleFromUrl'
// ...
const locale = getLocaleFromUrl(Astro.url)
const t = await getEntry('i18n', `${locale}/translation`)
const [_firstSlash, _prevLocale, ...rest] = Astro.url.pathname.split('/')
const slug = rest.join('/')
// ...
---

<div id="lang-modal" class="hidden">
  <div id="lang-wrapper">
    <ul class="lang-list">
      {
        Object.entries(languages).map(([lang, label]) => (
          <li>
            <a href={`/${lang}/${slug}`}>{label}</a>
          </li>
        ))
      }
    </ul>
  </div>
</div>
<button
  aria-label={t.data.locale_picker.button_label}
  type="button"
  id="lang-icon-button"
  title={t.data.locale_picker.button_label}
>
  <Svg iconName="alphabet" width={32} height={32} />
</button>
<!-- ... -->
```

In terms of event registration, I did almost the same thing as the search component, so let's skip it.

Finally, I added it to the navigation as I did for the theme switch component.

#### OG Image (Open Graph)

OG Images are dynamically generated via [the API endpoint functionality](https://docs.astro.build/en/guides/endpoints/) Astro provides. To make it simpler, I installed the `astro-og-canvas` library and used it like below. The workflow is as follows:

1. Get all content collections data for which you want to have OG images dynamically generated
2. Process the data so that the `OGImageRoute` can take as its prop `pages`
3. Pass it to the `OGImageRoute`

In my case, things around paths are a bit messy because of the locale directories, so I had to do some processing of paths.

```typescript title="og/[...slug].ts"
import { getCollection } from 'astro:content'
import { OGImageRoute } from 'astro-og-canvas'

const entries = await getCollection('blog')
const articles = Object.fromEntries(
  entries.map(({ slug, data, collection }) => {
    const locale = slug.slice(0, slug.indexOf('/'))
    const rawSlug = slug.slice(slug.indexOf('/') + 1)

    // e.g., "/en/blog/example1": { example1's data here }
    return [`${locale}/${collection}/${rawSlug}`, data]
  })
)

export const { getStaticPaths, GET } = OGImageRoute({
  param: 'slug', // this must be consistent with the dynamic path name
  pages: articles,
  getImageOptions: (_path, page: (typeof articles)[number]) => {
    return {
      title: page.title,
      description: page.description ?? '',
      bgGradient: [[26.99, 26.99, 30.99]],
      border: { color: [232, 232, 232], width: 5, side: 'block-end' },
      padding: 80,
      font: {
        title: {
          size: 64,
          lineHeight: 1.35,
          families: [
            'PixelMPlus10',
            'Arial',
            'Hiragino Kaku Gothic ProN',
            'Hiragino Sans',
          ],
          weight: 'Medium',
          color: [255, 255, 255],
        },
        description: {
          size: 36,
          lineHeight: 1.2,
          families: ['Arial', 'Hiragino Kaku Gothic ProN', 'Hiragino Sans'],
          weight: 'Normal',
          color: [255, 255, 255],
        },
      },
      logo: {
        path: './src/assets/images/logo.png',
        size: [80, 80],
      },
      fonts: ['./src/assets/fonts/PixelMplus10-Regular.woff2'],
    }
  },
})
```

For more info about the options, consult [the astro-og-canvas doc](https://github.com/delucis/astro-og-canvas/tree/latest/packages/astro-og-canvas).

Now you can access the og endpoint. Let's see one example of it. I created the head component that is supposed to be embedded in the base layout of this website.

```astro title="BaseHead.astro"
---
// ...
import type { Props as BaseLayoutProps } from '@/layouts/BaseLayout.astro'

type Props = BaseLayoutProps
// ...
const { title, description, og } = Astro.props
---
<!-- ... -->
<meta property="og:type" content="website" />
<meta property="og:url" content={Astro.url} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
{
  og.show && (
    <>
      <meta
        property="og:image"
        content={og.image ?? new URL('/blog-placeholder-1.jpg', Astro.url)}
      />
      <meta
        property="og:image:height"
        content={(og.height ?? 720).toString()}
      />
      <meta property="og:image:width" content={(og.width ?? 720).toString()} />
      <meta property="og:type" content={og.type ?? 'website'} />
    </>
  )
}
<meta property="twitter:url" content={Astro.url} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
{
  og.show && (
    <>
      <meta
        property="twitter:card"
        content={og.type === 'article' ? 'summary_large_image' : 'summary'}
      />
      <meta
        property="twitter:image"
        content={og.image ?? new URL('/blog-placeholder-1.jpg', Astro.url)}
      />
    </>
  )
}
<!-- ... -->
```

```astro title="BaseLayout.astro" {2, 24}
---
import BaseHead from '../components/BaseHead.astro'
// ...

// this is supposed to be imported from the BaseHead component
export type Props = {
  title: string
  description?: string
  og: {
    show: boolean
    image?: URL
    height?: number
    width?: number
    type?: 'article' | 'website'
  }
}

const { title, description, og } = Astro.props
---

<!doctype html>
<html lang={/* ... */}>
  <head>
    <BaseHead {title} description={description ?? ''} {og} />
  </head>
  <body data-pagefind-body>
    <!-- ... -->
  </body>
</html>
```

This page included, every blog article is wrapped by the blog layout, which in turn is done so by the base layout. In the meantime, the `og` prop is passed onto the base layout, and then the base head one after another.

```astro title="BlogLayout.astro" {24-33}
---
// ...
import type { MarkdownHeading } from 'astro'
import type { CollectionEntry } from 'astro:content'
// ...
import BaseLayout from '@/layouts/BaseLayout.astro'
// ...

type Props = {
  entry: CollectionEntry<'blog'>
  headings: MarkdownHeading[]
}

// ...
const { entry, headings } = Astro.props
const { data, collection, slug } = entry
const { title, description, category, tags, publishedAt, modifiedAt } = data
// ...
---

<BaseLayout
  title={title}
  description={description ?? ''}
  og={{
    show: true,
    height: 630,
    width: 1200,
    image: new URL(
      `/og/${locale}/${collection}/${slug.slice(slug.indexOf('/') + 1)}.png`,
      Astro.url
    ),
    type: 'article',
  }}
>
  <main>
    <!-- ... -->
  </main>
</BaseLayout>
<!-- ... -->
```

#### Styling inside articles

Aside from the detailed styling of the blog body part, here I picked up that of some specific elements.

##### KaTex

$\KaTeX$ beautifully styles mathematical expressions on a web page. For instance, this turns into...

```Markdown
$$
x = {-b \pm \sqrt{b^2-4ac} \over 2a}
$$
$$
( \sum_{k=1}^{n} a_k b_k )^2 \leq ( \sum_{k=1}^{n} {a_k}^2 ) ( \sum_{k=1}^{n} {b_k}^2 )
$$
$$
\int_{0}^{1} f(x) \ dx
= \lim_{n \to \infty} \dfrac{1}{n} \sum_{k=0}^{n-1} f \left (\dfrac{k}{n} \right)
$$
```

this! Very legible, isn't it?

$$
x = {-b \pm \sqrt{b^2-4ac} \over 2a}
$$
$$
( \sum_{k=1}^{n} a_k b_k )^2 \leq ( \sum_{k=1}^{n} {a_k}^2 ) ( \sum_{k=1}^{n} {b_k}^2 )
$$
$$
\int_{0}^{1} f(x) \ dx
= \lim_{n \to \infty} \dfrac{1}{n} \sum_{k=0}^{n-1} f \left (\dfrac{k}{n} \right)
$$

To use $\KaTeX$, I added the `katex`, `rehype-katex`, `remark-math` and `@types/katex` libraries, and then did the following code tweaks.

```typescript title="astro.config.ts" {2,9,13}
// ...
import rehypeKatex from 'rehype-katex'
// ...
export default defineConfig({
  // ...
  markdown: {
    // ...
    remarkPlugins: [
      remarkMath,
      // ...
    ],
    rehypePlugins: [
      rehypeKatex,
      // ...
    ],
  },
})
```

I had the $\KaTeX$ stylesheet read only in the layout for blog because it's not supposed to be used in other pages.

```astro title="BlogLayout.astro"
---
import 'katex/dist/katex.min.css'
// ...
---
<!-- ... -->
```

##### Code block

Up here, I put a bunch of code blocks to explain how each code works. I customized the syntax highlighting, code highlighting, and so on behind the scenes.

To that end, I added the `rehype-pretty-code` and `shiki` library and then tweaked the following parts.

\* The `rehype-pretty-code` uses the `shiki` behind the scenes and therefore it's necessary.

```typescript title="astro.config.ts" {2,7,11-20}
// ...
import rehypeKatex from 'rehype-katex'
// ...
export default defineConfig({
  // ...
  markdown: {
    syntaxHighlight: false,
    // ...
    rehypePlugins: [
      // ...
      [
        rehypePrettyCode,
        {
          theme: {
            light: 'github-dark',
            dark: 'github-dark',
          },
          grid: false,
        },
      ],
      // ...
    ],
  },
})
```

Next, I created two components for HTML elements shown below. As to this nested structure (and the better part of the code styling), where the code component is included in that of figure, I consulted the Github repo of [haxibami.net](https://www.haxibami.net/)

```astro title="Figure.astro"
---
import AstroCode from './Code.astro'

export type Props = {
  'data-rehype-pretty-code-figure'?: ''
}

const props = Astro.props
const isCodeFigure = Object.hasOwn(props, 'data-rehype-pretty-code-figure')
---

{
  isCodeFigure ? (
    <AstroCode {...props}>
      <slot />
    </AstroCode>
  ) : (
    <figure {...props}>
      <slot />
    </figure>
  )
}
```

```astro title="Code.astro"
---
const props = Astro.props
---

<figure {...props}>
  <slot />
</figure>
<style>
  figure {
    margin: 1.75rem 0 1.5rem 0;
    max-width: 86.5vw;
    position: relative;
    font-size: 0.85rem;
    & :global(pre) {
      border-radius: 0.25rem;
      overflow-x: auto;
    }
    & :global(code) {
      font-family: var(--code-font);
      counter-reset: line;
      display: grid;
      & :global([data-line]) {
        border-left: 4px solid transparent;
        padding: 0 0.55rem;
      }
      & :global([data-line]::before) {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        width: 1rem;
        margin-right: 1.05rem;
        text-align: right;
        color: var(--gray-light);
      }
      & :global([data-highlighted-line]) {
        border-left-color: var(--code-highlight-border);
        background-color: var(--code-highlight);
        :global(span) {
          background-color: unset;
        }
      }
      & :global([data-highlighted-chars]) {
        background-color: var(--gray-light);
        padding: 0.25rem;
        border-radius: 0.25rem;
        & :global(span) {
          background-color: unset;
        }
      }
    }
    & :global([data-rehype-pretty-code-title]) {
      font-family: var(--code-font);
      & + :global(pre) {
        padding: 2.85rem 0 0.75rem 0;
      }
    }
    & :global(pre:not([data-rehype-pretty-code-title] + pre)) {
      padding: 0.75rem 0;
    }
    & :global([data-rehype-pretty-code-title]) {
      max-width: 70vw;
      position: absolute;
      top: 0;
      left: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      padding: 0.25rem 0.75rem;
      color: var(--gray-dark);
      background: var(--gray);
      border-radius: 0.15rem 0.15rem 0.15rem 0;
    }
  }
  @media (min-width: 1024px) {
    figure {
      max-width: 59.5vw;
    }
  }
  :global(pre[data-theme*=' ']),
  :global(pre[data-theme*=' '] span) {
    color: var(--shiki-light);
    background: var(--shiki-light-bg);
  }
</style>
```

##### Anchor headings

This article included, all my blog articles have headings with anchor links, which enables the table of content to spot and lead you to every one of them.

To make it work, I added the `rehype-autolink-headings` library and tweaked the following parts.

```typescript title="astro.config.ts" {2,10-22}
// ...
import rehypeAutolinkHeadings from 'rehype-autolink-headings'
// ...
export default defineConfig({
  // ...
  markdown: {
    // ...
    rehypePlugins: [
      // ...
      [
        rehypeAutolinkHeadings,
        {
          behavior: 'prepend',
          content: h(
            'span.heading-anchor-icon',
            {
              title: 'Anchor link',
            },
            ['#']
          ),
        },
      ],
      // ...
    ],
  },
})
```

And then I added the styling for anchor links in every content layouts. Below is the example of the blog layout.

```astro title="BlogLayout.astro"
---
// ...
---

<BaseLayout
  <!-- ... -->
>
  <main>
    <article>
      <!-- ... -->
    </article>
  </main>
</BaseLayout>
<style>
  article {
    /* ... */
    .prose {
      /* ... */
      & :global(a):has(.heading-anchor-icon) {
        text-decoration: none;
        font-family: var(--base-font);
        & :global(span.heading-anchor-icon) {
          color: var(--fg);
          margin-right: 0.5rem;
        }
        &:hover {
          text-decoration: underline;
          text-underline-offset: 4px;
          text-decoration-color: var(--fg);
        }
        /* ... */
      }
    }
  }
</style>
```

### Front Matter CMS

Along with a choice of framework, what takes you ages to decide is that of CMS(Content Management System). I fell in love with [Front Matter CMS](https://frontmatter.codes/) for the following reasons:

- Writing and storing articles in local
- Markdown/MDX file format

It's unlike other headless CMS in that it's a VS Code extension and works in local, in your code editor! This centralizes all the editing work: code tweaks, blog writing, and deployment. I believe it'd especially be a huge advantage to developers.

### Cloudflare Pages

#### Why Cloudflare?

I decided to use Cloudflare Pages for deploying my website for the following reasons:

- the generous free plan
- Custom email addresses for your domain available
- own domains available (paid)

I suppose the free plan suffices for a small project like my website in most cases.

## Afterword

I spent a tremendous amount of time reading articles about how to create my personal website, watching a bunch of tutorials for various JS frameworks on YouTube, and actually getting to work on it. As a novice, it felt as if I were stargazing when I was looking for a constellation of frameworks.

Among them, I bumped into outstanding and brilliant one above all: Next.js, a framework for React. Since then, I started creating my personal website, simultaneously learning it. After 8 months or so, I successfully built a decent Next.js website.

However, long story short, we broke up finally. How come? It's fascinating in providing a full range of features, handling the backend stuff on behalf of me, and so on, but therein lies the rub; as it upgrades and becomes equipped with a lot more features, it seems to be deviating from the JS standard. Plus, I've found it hard to catch up with those continuously upcoming features. (I barely stuck at it until the App Router...)

In the end, I encountered with Astro, a framework for JS frameworks, if you like. What I love most about it is its flexibility; it keeps its functionality to a bare minimum and leaves enough room for your customization. In my case, I avoid using such JS frameworks as React where possible and stick to using vanilla JS(TypeScript).

## Reference
